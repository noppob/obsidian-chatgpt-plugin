/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChatGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4o",
  temperature: 0.7,
  maxTokens: 2e3,
  systemPrompt: "You are a helpful assistant. Answer questions clearly and concisely.",
  responseFormat: "**ChatGPT:**\n{response}"
};
var ChatGPTPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.floatingButton = null;
    this.selectedTextCache = "";
  }
  // テキスト選択のキャッシュ（モバイル対応）
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("message-square", "Ask ChatGPT (Custom Prompt)", (evt) => {
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (markdownView) {
        const editor = markdownView.editor;
        this.askChatGPTCustom(editor);
      } else {
        new import_obsidian.Notice("Please open a note first");
      }
    });
    this.registerDomEvent(document, "selectionchange", () => {
      this.handleSelectionChange();
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selectedText = editor.getSelection();
        if (selectedText && selectedText.trim()) {
          menu.addItem((item) => {
            item.setTitle("\u2728 Ask ChatGPT").setIcon("message-square").onClick(async () => {
              this.askChatGPT(editor);
            });
          });
          menu.addItem((item) => {
            item.setTitle("\u{1F4AC} Ask ChatGPT (Custom)").setIcon("edit").onClick(async () => {
              this.askChatGPTCustom(editor);
            });
          });
        }
      })
    );
    this.addCommand({
      id: "ask-chatgpt",
      name: "Ask ChatGPT about selected text",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPT(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "ask-chatgpt-custom",
      name: "Ask ChatGPT with custom prompt",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPTCustom(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new ChatGPTSettingTab(this.app, this));
  }
  handleSelectionChange() {
    const selection = window.getSelection();
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (selection && selection.toString().trim() && markdownView) {
      this.showFloatingButton();
    } else {
      this.hideFloatingButton();
    }
  }
  showFloatingButton() {
    if (this.floatingButton)
      return;
    const selection = window.getSelection();
    if (selection) {
      this.selectedTextCache = selection.toString().trim();
    }
    this.floatingButton = document.body.createDiv("chatgpt-floating-button");
    this.floatingButton.innerHTML = "\u{1F4AC}";
    this.floatingButton.setAttribute("aria-label", "Ask ChatGPT");
    this.floatingButton.addEventListener("click", async () => {
      this.hideFloatingButton();
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (markdownView) {
        await this.askChatGPTWithModeSwitch(markdownView);
      }
    });
  }
  hideFloatingButton() {
    if (this.floatingButton) {
      this.floatingButton.remove();
      this.floatingButton = null;
    }
  }
  async askChatGPTWithModeSwitch(view) {
    const state = view.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await view.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    const editor = view.editor;
    await this.askChatGPTCustom(editor, this.selectedTextCache);
    this.selectedTextCache = "";
    if (wasInReadingMode) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      await view.setState({ ...state, mode: "preview" }, { history: false });
    }
  }
  async askChatGPT(editor) {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let selectedText = editor.getSelection();
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    try {
      new import_obsidian.Notice("Asking ChatGPT...");
      const response = await this.callOpenAI(selectedText);
      const formattedResponse = this.settings.responseFormat.replace(
        "{response}",
        response
      );
      const lastLine = editor.lastLine();
      const lastLineLength = editor.getLine(lastLine).length;
      const insertText = `

---

**Question:**
${selectedText}

${formattedResponse}
`;
      editor.replaceRange(
        insertText,
        { line: lastLine, ch: lastLineLength }
      );
      const newLastLine = editor.lastLine();
      editor.setCursor({ line: newLastLine, ch: 0 });
      new import_obsidian.Notice("Response inserted!");
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("ChatGPT Error:", error);
    } finally {
      if (wasInReadingMode) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        await markdownView.setState({ ...state, mode: "preview" }, { history: false });
      }
    }
  }
  async askChatGPTCustom(editor, cachedText) {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let selectedText = cachedText || editor.getSelection();
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    new CustomPromptModal(this.app, async (customPrompt) => {
      try {
        new import_obsidian.Notice("Asking ChatGPT...");
        const fullPrompt = `${customPrompt}

---
${selectedText}`;
        const response = await this.callOpenAI(fullPrompt);
        const formattedResponse = this.settings.responseFormat.replace(
          "{response}",
          response
        );
        const lastLine = editor.lastLine();
        const lastLineLength = editor.getLine(lastLine).length;
        const insertText = `

---

**Prompt:**
${customPrompt}

**Context:**
${selectedText}

${formattedResponse}
`;
        editor.replaceRange(
          insertText,
          { line: lastLine, ch: lastLineLength }
        );
        const newLastLine = editor.lastLine();
        editor.setCursor({ line: newLastLine, ch: 0 });
        new import_obsidian.Notice("Response inserted!");
        if (wasInReadingMode) {
          await new Promise((resolve) => setTimeout(resolve, 500));
          await markdownView.setState({ ...state, mode: "preview" }, { history: false });
        }
      } catch (error) {
        new import_obsidian.Notice(`Error: ${error.message}`);
        console.error("ChatGPT Error:", error);
        if (wasInReadingMode) {
          await new Promise((resolve) => setTimeout(resolve, 500));
          await markdownView.setState({ ...state, mode: "preview" }, { history: false });
        }
      }
    }, wasInReadingMode ? { view: markdownView, state, wasInReadingMode } : void 0).open();
  }
  async callOpenAI(prompt) {
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.settings.model,
        messages: [
          {
            role: "system",
            content: this.settings.systemPrompt
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: this.settings.temperature,
        max_tokens: this.settings.maxTokens
      })
    });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message || "OpenAI API Error");
    }
    if (!data.choices || data.choices.length === 0) {
      throw new Error("No response from ChatGPT");
    }
    return data.choices[0].message.content.trim();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CustomPromptModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, readingModeInfo) {
    super(app);
    this.focusInterval = null;
    this.onSubmit = onSubmit;
    this.readingModeInfo = readingModeInfo;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("chatgpt-custom-modal");
    contentEl.createEl("h2", { text: "Custom prompt for ChatGPT" });
    const inputEl = contentEl.createEl("textarea", {
      placeholder: "Enter your question or instruction..."
    });
    inputEl.style.width = "100%";
    inputEl.style.minHeight = "100px";
    inputEl.style.marginBottom = "10px";
    inputEl.setAttribute("inputmode", "text");
    inputEl.setAttribute("autocomplete", "off");
    inputEl.setAttribute("autocorrect", "off");
    inputEl.setAttribute("spellcheck", "false");
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.textAlign = "right";
    const submitBtn = buttonContainer.createEl("button", { text: "Ask" });
    submitBtn.addEventListener("click", () => {
      const prompt = inputEl.value.trim();
      if (prompt) {
        this.onSubmit(prompt);
        this.close();
      } else {
        new import_obsidian.Notice("Please enter a prompt");
      }
    });
    inputEl.addEventListener("blur", () => {
      setTimeout(() => {
        if (this.modalEl.isShown()) {
          inputEl.focus();
        }
      }, 10);
    });
    inputEl.focus();
    setTimeout(() => {
      inputEl.focus();
    }, 50);
    setTimeout(() => {
      inputEl.focus();
    }, 150);
    this.focusInterval = window.setInterval(() => {
      if (document.activeElement !== inputEl && this.modalEl.isShown()) {
        inputEl.focus();
      }
    }, 500);
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.focusInterval !== null) {
      window.clearInterval(this.focusInterval);
      this.focusInterval = null;
    }
    if (this.readingModeInfo && this.readingModeInfo.wasInReadingMode) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      await this.readingModeInfo.view.setState(
        { ...this.readingModeInfo.state, mode: "preview" },
        { history: false }
      );
    }
  }
};
var ChatGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ChatGPT Integration Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key (get it from platform.openai.com)").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select ChatGPT model").addDropdown(
      (dropdown) => dropdown.addOption("gpt-4o", "GPT-4o (Latest, Recommended)").addOption("gpt-4o-mini", "GPT-4o Mini (Faster, Cheaper)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-4", "GPT-4").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0-2). Lower = more focused, Higher = more creative").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum length of response").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.maxTokens = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("System Prompt").setDesc("Default instruction for ChatGPT").addTextArea((text) => {
      text.setPlaceholder("You are a helpful assistant...").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("Response Format").setDesc("How to format the response. Use {response} as placeholder.").addTextArea((text) => {
      text.setPlaceholder("**ChatGPT:**\n{response}").setValue(this.plugin.settings.responseFormat).onChange(async (value) => {
        this.plugin.settings.responseFormat = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    containerEl.createEl("h3", { text: "How to use" });
    const usageEl = containerEl.createEl("div");
    usageEl.innerHTML = `
			<ol>
				<li>Select text in your note</li>
				<li>Press <kbd>Ctrl/Cmd + P</kbd> and search for "Ask ChatGPT"</li>
				<li>Wait for the response to be inserted</li>
			</ol>
			<p><strong>Commands:</strong></p>
			<ul>
				<li><strong>Ask ChatGPT about selected text</strong>: Ask a general question about the selected text</li>
				<li><strong>Ask ChatGPT with custom prompt</strong>: Specify your own question or instruction</li>
			</ul>
		`;
  }
};
