/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChatGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var MobileDebugLogger = class {
  constructor(plugin) {
    this.logs = [];
    this.plugin = plugin;
  }
  log(message, data) {
    var _a;
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().substring(11, 19);
    const logEntry = data ? `[${timestamp}] ${message}: ${JSON.stringify(data).substring(0, 100)}` : `[${timestamp}] ${message}`;
    this.logs.push(logEntry);
    console.log(logEntry);
    if ((_a = this.plugin.settings) == null ? void 0 : _a.debugMode) {
      new import_obsidian.Notice(logEntry, 3e3);
    }
  }
  async saveToFile() {
    try {
      const logContent = this.logs.join("\n");
      const vault = this.plugin.app.vault;
      await vault.adapter.write("chatgpt_debug_logs.txt", logContent);
      new import_obsidian.Notice("\u2705 Debug log saved to chatgpt_debug_logs.txt", 5e3);
    } catch (error) {
      new import_obsidian.Notice(`\u274C Failed to save log: ${error.message}`, 5e3);
    }
  }
  clear() {
    this.logs = [];
    new import_obsidian.Notice("Debug log cleared");
  }
  getLogsCount() {
    return this.logs.length;
  }
};
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4o",
  temperature: 0.7,
  maxTokens: 2e3,
  systemPrompt: "You are a helpful assistant. Answer questions clearly and concisely.",
  responseFormat: "**ChatGPT:**\n{response}",
  debugMode: false,
  useWebSearch: false,
  usageHistory: []
};
var ChatGPTPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.floatingButton = null;
    this.selectedTextCache = "";
  }
  async onload() {
    this.debugLogger = new MobileDebugLogger(this);
    this.debugLogger.log("\u{1F680} ChatGPT Plugin loaded");
    await this.loadSettings();
    this.addRibbonIcon("message-square", "Ask ChatGPT (Custom Prompt)", (evt) => {
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (markdownView) {
        const editor = markdownView.editor;
        this.askChatGPTCustom(editor);
      } else {
        new import_obsidian.Notice("Please open a note first");
      }
    });
    this.registerDomEvent(document, "selectionchange", () => {
      this.handleSelectionChange();
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selectedText = editor.getSelection();
        if (selectedText && selectedText.trim()) {
          menu.addItem((item) => {
            item.setTitle("\u2728 Ask ChatGPT").setIcon("message-square").onClick(async () => {
              this.askChatGPT(editor);
            });
          });
          menu.addItem((item) => {
            item.setTitle("\u{1F4AC} Ask ChatGPT (Custom)").setIcon("edit").onClick(async () => {
              this.askChatGPTCustom(editor);
            });
          });
        }
      })
    );
    this.addCommand({
      id: "ask-chatgpt",
      name: "Ask ChatGPT about selected text",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPT(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "ask-chatgpt-custom",
      name: "Ask ChatGPT with custom prompt",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPTCustom(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new ChatGPTSettingTab(this.app, this));
  }
  showFloatingButton() {
    if (this.floatingButton)
      return;
    this.debugLogger.log("\u{1F4AC} Creating floating button");
    this.floatingButton = document.body.createDiv("chatgpt-floating-button");
    this.floatingButton.innerHTML = "\u{1F4AC}";
    this.floatingButton.setAttribute("aria-label", "Ask ChatGPT");
    this.floatingButton.addEventListener("click", async () => {
      const cachedText = this.selectedTextCache;
      this.debugLogger.log("\u{1F5B1}\uFE0F Floating button clicked", {
        cacheLength: cachedText.length,
        preview: cachedText.substring(0, 50)
      });
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!markdownView) {
        new import_obsidian.Notice("Please open a note first");
        return;
      }
      if (!cachedText || !cachedText.trim()) {
        new import_obsidian.Notice("\u{1F4DD} Please select text first");
        return;
      }
      const editor = markdownView.editor;
      await this.askChatGPTCustom(editor, cachedText);
      this.selectedTextCache = "";
    });
  }
  handleSelectionChange() {
    const selection = window.getSelection();
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    this.debugLogger.log("\u{1F4DD} Selection changed", {
      length: (selection == null ? void 0 : selection.toString().length) || 0
    });
    if (selection && selection.toString().trim() && markdownView) {
      this.selectedTextCache = selection.toString().trim();
      this.debugLogger.log("\u{1F4BE} Text cached", {
        cacheLength: this.selectedTextCache.length
      });
      this.showFloatingButton();
    } else {
      this.selectedTextCache = "";
      this.hideFloatingButton();
    }
  }
  hideFloatingButton() {
    if (this.floatingButton) {
      this.floatingButton.remove();
      this.floatingButton = null;
    }
  }
  async askChatGPT(editor) {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let selectedText = editor.getSelection();
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    try {
      new import_obsidian.Notice("Asking ChatGPT...");
      const response = await this.callOpenAI(selectedText);
      const formattedResponse = this.settings.responseFormat.replace(
        "{response}",
        response
      );
      const lastLine = editor.lastLine();
      const lastLineLength = editor.getLine(lastLine).length;
      const insertText = `

---

**Question:**
${selectedText}

${formattedResponse}
`;
      editor.replaceRange(
        insertText,
        { line: lastLine, ch: lastLineLength }
      );
      const newLastLine = editor.lastLine();
      editor.setCursor({ line: newLastLine, ch: 0 });
      new import_obsidian.Notice("Response inserted!");
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("ChatGPT Error:", error);
    } finally {
      if (wasInReadingMode) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        await markdownView.setState({ ...state, mode: "preview" }, { history: false });
      }
    }
  }
  async askChatGPTCustom(editor, selectedText) {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    if (!selectedText) {
      selectedText = editor.getSelection();
    }
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    new InteractiveChatModal(
      this.app,
      this,
      selectedText,
      editor,
      wasInReadingMode ? { view: markdownView, state, wasInReadingMode } : void 0
    ).open();
  }
  async callOpenAI(prompt) {
    const requestBody = {
      model: this.settings.model,
      input: [
        {
          role: "system",
          content: this.settings.systemPrompt
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: this.settings.temperature,
      max_output_tokens: this.settings.maxTokens
    };
    if (this.settings.useWebSearch) {
      requestBody.tools = [{ type: "web_search" }];
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/responses",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message || "OpenAI API Error");
    }
    if (data.usage) {
      this.recordUsage(
        this.settings.model,
        data.usage.prompt_tokens || data.usage.input_tokens || 0,
        data.usage.completion_tokens || data.usage.output_tokens || 0
      );
    }
    if (data.output_text) {
      return data.output_text.trim();
    }
    if (data.output && data.output.length > 0) {
      for (const outputItem of data.output) {
        if (outputItem.type === "message" && outputItem.content && outputItem.content.length > 0) {
          for (const contentItem of outputItem.content) {
            if (contentItem.type === "output_text" && contentItem.text) {
              return contentItem.text.trim();
            }
          }
        }
      }
    }
    throw new Error("No response from ChatGPT");
  }
  // 会話履歴を使ったOpenAI API呼び出し（ストリーミング対応 - Responses API使用）
  async callOpenAIWithHistoryStreaming(messages, onChunk) {
    var _a, _b;
    const requestBody = {
      model: this.settings.model,
      input: messages,
      temperature: this.settings.temperature,
      max_output_tokens: this.settings.maxTokens,
      stream: true
      // ストリーミング有効化
    };
    if (this.settings.useWebSearch) {
      requestBody.tools = [{ type: "web_search" }];
    }
    const response = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(((_a = errorData.error) == null ? void 0 : _a.message) || "OpenAI API Error");
    }
    const reader = (_b = response.body) == null ? void 0 : _b.getReader();
    if (!reader) {
      throw new Error("Failed to get response reader");
    }
    const decoder = new TextDecoder();
    let fullText = "";
    let buffer = "";
    let usageData = void 0;
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim() === "" || line.trim() === "data: [DONE]")
            continue;
          if (line.startsWith("event:")) {
            continue;
          }
          if (!line.startsWith("data: "))
            continue;
          try {
            const jsonStr = line.substring(6);
            const data = JSON.parse(jsonStr);
            if (data.delta !== void 0) {
              const chunk = data.delta;
              fullText += chunk;
              onChunk(chunk);
            }
            if (data.usage) {
              usageData = data.usage;
            }
          } catch (e) {
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    if (usageData) {
      this.recordUsage(
        this.settings.model,
        usageData.prompt_tokens || usageData.input_tokens || 0,
        usageData.completion_tokens || usageData.output_tokens || 0
      );
    } else {
      const estimatedPromptTokens = Math.ceil(JSON.stringify(messages).length / 4);
      const estimatedCompletionTokens = Math.ceil(fullText.length / 4);
      this.recordUsage(this.settings.model, estimatedPromptTokens, estimatedCompletionTokens);
    }
    return { fullText, usage: usageData };
  }
  // 会話履歴を使ったOpenAI API呼び出し（対話型モーダル用・非ストリーミング版）
  async callOpenAIWithHistory(messages) {
    const requestBody = {
      model: this.settings.model,
      input: messages,
      temperature: this.settings.temperature,
      max_output_tokens: this.settings.maxTokens
    };
    if (this.settings.useWebSearch) {
      requestBody.tools = [{ type: "web_search" }];
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/responses",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message || "OpenAI API Error");
    }
    if (data.usage) {
      this.recordUsage(
        this.settings.model,
        data.usage.prompt_tokens || data.usage.input_tokens || 0,
        data.usage.completion_tokens || data.usage.output_tokens || 0
      );
    }
    if (data.output_text) {
      return data.output_text.trim();
    }
    if (data.output && data.output.length > 0) {
      for (const outputItem of data.output) {
        if (outputItem.type === "message" && outputItem.content && outputItem.content.length > 0) {
          for (const contentItem of outputItem.content) {
            if (contentItem.type === "output_text" && contentItem.text) {
              return contentItem.text.trim();
            }
          }
        }
      }
    }
    throw new Error("No response from ChatGPT");
  }
  // コスト計算（モデル別料金）
  calculateCost(model, promptTokens, completionTokens) {
    const pricing = {
      "gpt-5.2": { input: 1.75, output: 7 },
      "gpt-5.1": { input: 1.25, output: 5 },
      "gpt-5": { input: 1, output: 4 },
      "gpt-5-mini": { input: 0.25, output: 1 },
      "gpt-5-nano": { input: 0.1, output: 0.4 },
      "gpt-4o": { input: 2.5, output: 10 },
      "gpt-4o-mini": { input: 0.15, output: 0.6 },
      "gpt-4-turbo": { input: 10, output: 30 },
      "gpt-4": { input: 30, output: 60 },
      "gpt-3.5-turbo": { input: 0.5, output: 1.5 }
    };
    const modelPricing = pricing[model] || pricing["gpt-4o"];
    const inputCost = promptTokens / 1e6 * modelPricing.input;
    const outputCost = completionTokens / 1e6 * modelPricing.output;
    return inputCost + outputCost;
  }
  // 使用量を記録
  recordUsage(model, promptTokens, completionTokens) {
    const totalTokens = promptTokens + completionTokens;
    const estimatedCost = this.calculateCost(model, promptTokens, completionTokens);
    const record = {
      date: (/* @__PURE__ */ new Date()).toISOString(),
      model,
      promptTokens,
      completionTokens,
      totalTokens,
      estimatedCost
    };
    this.settings.usageHistory.push(record);
    this.saveSettings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var InteractiveChatModal = class extends import_obsidian.Modal {
  constructor(app, plugin, selectedText, editor, readingModeInfo) {
    super(app);
    // 会話履歴（API送信用、システムプロンプト + 選択テキスト含む）
    this.messages = [];
    // 表示用会話履歴（ユーザーとアシスタントのやり取りのみ）
    this.displayMessages = [];
    this.isLoading = false;
    this.plugin = plugin;
    this.selectedText = selectedText;
    this.editor = editor;
    this.readingModeInfo = readingModeInfo;
    this.messages.push({
      role: "system",
      content: this.plugin.settings.systemPrompt
    });
    this.messages.push({
      role: "system",
      content: `Selected context from the document:

${selectedText}`
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("chatgpt-interactive-modal");
    contentEl.createEl("h2", { text: "\u{1F4AC} ChatGPT Interactive Chat" });
    const contextSection = contentEl.createDiv("chatgpt-context-section");
    const contextHeader = contextSection.createDiv("chatgpt-context-header");
    contextHeader.createEl("strong", { text: "\u{1F4C4} Selected Context" });
    const toggleIcon = contextHeader.createSpan("chatgpt-toggle-icon");
    toggleIcon.textContent = "\u25BC";
    const contextContent = contextSection.createDiv("chatgpt-context-content");
    contextContent.style.display = "block";
    const contextText = contextContent.createEl("div", { cls: "chatgpt-context-text" });
    contextText.textContent = this.selectedText.length > 200 ? this.selectedText.substring(0, 200) + "..." : this.selectedText;
    this.contextContentEl = contextContent;
    this.contextToggleIconEl = toggleIcon;
    contextHeader.addEventListener("click", () => {
      if (contextContent.style.display === "none") {
        contextContent.style.display = "block";
        toggleIcon.textContent = "\u25BC";
      } else {
        contextContent.style.display = "none";
        toggleIcon.textContent = "\u25B6";
      }
    });
    const inputSection = contentEl.createDiv("chatgpt-input-section");
    const inputHeader = inputSection.createDiv("chatgpt-input-header");
    inputHeader.createEl("strong", { text: "\u270D\uFE0F Input Area" });
    const inputToggleIcon = inputHeader.createSpan("chatgpt-toggle-icon");
    inputToggleIcon.textContent = "\u25BC";
    const inputContent = inputSection.createDiv("chatgpt-input-content");
    inputContent.style.display = "block";
    this.inputEl = inputContent.createEl("textarea", {
      placeholder: "\u{1F4AC} \u3053\u3053\u306B\u8CEA\u554F\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044...",
      cls: "chatgpt-input"
    });
    this.inputEl.setAttribute("inputmode", "text");
    this.inputEl.setAttribute("autocomplete", "off");
    this.inputEl.setAttribute("autocorrect", "off");
    this.inputEl.setAttribute("spellcheck", "false");
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSend();
      }
    });
    const buttonContainer = inputContent.createDiv("chatgpt-button-container");
    this.sendBtn = buttonContainer.createEl("button", { text: "\u9001\u4FE1", cls: "chatgpt-send-btn" });
    this.sendBtn.addEventListener("click", () => this.handleSend());
    this.insertBtn = buttonContainer.createEl("button", { text: "\u633F\u5165\u3057\u3066\u9589\u3058\u308B", cls: "chatgpt-insert-btn" });
    this.insertBtn.addEventListener("click", () => this.handleInsertAndClose());
    if (this.plugin.settings.debugMode) {
      const debugBtn = buttonContainer.createEl("button", { text: "\u{1F41B} \u30ED\u30B0\u4FDD\u5B58", cls: "chatgpt-cancel-btn" });
      debugBtn.addEventListener("click", async () => {
        await this.plugin.debugLogger.saveToFile();
      });
    }
    const cancelBtn = buttonContainer.createEl("button", { text: "\u30AD\u30E3\u30F3\u30BB\u30EB", cls: "chatgpt-cancel-btn" });
    cancelBtn.addEventListener("click", () => this.close());
    inputHeader.addEventListener("click", () => {
      if (inputContent.style.display === "none") {
        inputContent.style.display = "block";
        inputToggleIcon.textContent = "\u25BC";
      } else {
        inputContent.style.display = "none";
        inputToggleIcon.textContent = "\u25B6";
      }
    });
    this.conversationEl = contentEl.createDiv("chatgpt-conversation");
    setTimeout(() => {
      this.inputEl.focus();
      this.inputEl.click();
      this.inputEl.setSelectionRange(0, 0);
    }, 150);
  }
  async handleSend() {
    const userInput = this.inputEl.value.trim();
    if (!userInput || this.isLoading)
      return;
    this.displayMessages.push({ role: "user", content: userInput });
    this.messages.push({ role: "user", content: userInput });
    this.inputEl.value = "";
    if (this.contextContentEl) {
      this.contextContentEl.style.display = "none";
      this.contextToggleIconEl.textContent = "\u25B6";
    }
    await this.renderConversation();
    this.setLoading(true);
    const assistantMessageIndex = this.displayMessages.length;
    this.displayMessages.push({ role: "assistant", content: "" });
    const messageEl = this.conversationEl.createDiv("chatgpt-message chatgpt-message-assistant");
    const iconEl = messageEl.createSpan("chatgpt-message-icon");
    iconEl.textContent = "\u{1F916}";
    const contentEl = messageEl.createDiv("chatgpt-message-content");
    contentEl.textContent = "";
    try {
      const result = await this.plugin.callOpenAIWithHistoryStreaming(
        this.messages,
        async (chunk) => {
          this.displayMessages[assistantMessageIndex].content += chunk;
          contentEl.empty();
          await import_obsidian.MarkdownRenderer.renderMarkdown(
            this.displayMessages[assistantMessageIndex].content,
            contentEl,
            "",
            null
          );
          this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
        }
      );
      this.messages.push({ role: "assistant", content: result.fullText });
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("ChatGPT Error:", error);
      this.displayMessages.splice(assistantMessageIndex - 1, 2);
      this.messages.pop();
      this.inputEl.value = userInput;
      messageEl.remove();
    } finally {
      this.setLoading(false);
      this.inputEl.focus();
    }
  }
  async renderConversation() {
    this.conversationEl.empty();
    if (this.displayMessages.length === 0) {
      const emptyMsg = this.conversationEl.createDiv("chatgpt-empty-message");
      emptyMsg.textContent = "\u8CEA\u554F\u3092\u5165\u529B\u3057\u3066\u4F1A\u8A71\u3092\u59CB\u3081\u307E\u3057\u3087\u3046";
      return;
    }
    for (const msg of this.displayMessages) {
      const messageEl = this.conversationEl.createDiv(`chatgpt-message chatgpt-message-${msg.role}`);
      const iconEl = messageEl.createSpan("chatgpt-message-icon");
      iconEl.textContent = msg.role === "user" ? "\u{1F4AC}" : "\u{1F916}";
      const contentEl = messageEl.createDiv("chatgpt-message-content");
      await import_obsidian.MarkdownRenderer.renderMarkdown(
        msg.content,
        contentEl,
        "",
        null
      );
    }
    this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
  }
  setLoading(loading) {
    this.isLoading = loading;
    this.sendBtn.disabled = loading;
    this.insertBtn.disabled = loading;
    this.inputEl.disabled = loading;
    if (loading) {
      this.sendBtn.textContent = "\u9001\u4FE1\u4E2D...";
      const loadingMsg = this.conversationEl.createDiv("chatgpt-message chatgpt-message-loading");
      loadingMsg.innerHTML = '<span class="chatgpt-message-icon">\u{1F916}</span><div class="chatgpt-message-content">\u8003\u3048\u4E2D...</div>';
      this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
    } else {
      this.sendBtn.textContent = "\u9001\u4FE1";
      const loadingMsg = this.conversationEl.querySelector(".chatgpt-message-loading");
      if (loadingMsg)
        loadingMsg.remove();
    }
  }
  async handleInsertAndClose() {
    if (this.displayMessages.length === 0) {
      new import_obsidian.Notice("\u4F1A\u8A71\u5C65\u6B74\u304C\u3042\u308A\u307E\u305B\u3093");
      return;
    }
    let conversationText = `

---

**Selected Context:**
${this.selectedText}

**ChatGPT Conversation:**

`;
    this.displayMessages.forEach((msg, index) => {
      const questionNum = Math.floor(index / 2) + 1;
      if (msg.role === "user") {
        conversationText += `**==Q${questionNum}:==** ${msg.content}

`;
      } else {
        conversationText += `**==A${questionNum}:==** ${msg.content}

`;
      }
    });
    const lastLine = this.editor.lastLine();
    const lastLineLength = this.editor.getLine(lastLine).length;
    this.editor.replaceRange(
      conversationText,
      { line: lastLine, ch: lastLineLength }
    );
    const newLastLine = this.editor.lastLine();
    this.editor.setCursor({ line: newLastLine, ch: 0 });
    new import_obsidian.Notice("\u4F1A\u8A71\u5C65\u6B74\u3092\u633F\u5165\u3057\u307E\u3057\u305F\uFF01");
    this.close();
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.readingModeInfo && this.readingModeInfo.wasInReadingMode) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      await this.readingModeInfo.view.setState(
        { ...this.readingModeInfo.state, mode: "preview" },
        { history: false }
      );
    }
  }
};
var ChatGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  displayUsageStats(containerEl) {
    const now = /* @__PURE__ */ new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const thisMonthRecords = this.plugin.settings.usageHistory.filter((record) => {
      const recordDate = new Date(record.date);
      return recordDate.getMonth() === currentMonth && recordDate.getFullYear() === currentYear;
    });
    const modelStats = {};
    let totalCost = 0;
    let totalTokens = 0;
    thisMonthRecords.forEach((record) => {
      if (!modelStats[record.model]) {
        modelStats[record.model] = { tokens: 0, cost: 0, count: 0 };
      }
      modelStats[record.model].tokens += record.totalTokens;
      modelStats[record.model].cost += record.estimatedCost;
      modelStats[record.model].count += 1;
      totalCost += record.estimatedCost;
      totalTokens += record.totalTokens;
    });
    const usageSection = containerEl.createDiv("chatgpt-usage-section");
    usageSection.createEl("h3", { text: "\u{1F4CA} \u4ECA\u6708\u306E\u5229\u7528\u6599\u91D1" });
    const statsSummary = usageSection.createDiv("chatgpt-usage-summary");
    statsSummary.innerHTML = `
			<div style="background-color: var(--background-secondary); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
				<div style="font-size: 24px; font-weight: bold; color: var(--text-accent);">
					$${totalCost.toFixed(4)}
				</div>
				<div style="margin-top: 5px; color: var(--text-muted); font-size: 14px;">
					\u5408\u8A08 ${totalTokens.toLocaleString()} \u30C8\u30FC\u30AF\u30F3 / ${thisMonthRecords.length} \u30EA\u30AF\u30A8\u30B9\u30C8
				</div>
			</div>
		`;
    if (Object.keys(modelStats).length > 0) {
      const breakdownEl = usageSection.createDiv("chatgpt-usage-breakdown");
      breakdownEl.createEl("strong", { text: "\u30E2\u30C7\u30EB\u5225\u5185\u8A33:" });
      breakdownEl.style.marginTop = "10px";
      const table = breakdownEl.createEl("table");
      table.style.width = "100%";
      table.style.marginTop = "10px";
      table.style.borderCollapse = "collapse";
      const headerRow = table.createEl("tr");
      headerRow.innerHTML = `
				<th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--background-modifier-border);">\u30E2\u30C7\u30EB</th>
				<th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--background-modifier-border);">\u30EA\u30AF\u30A8\u30B9\u30C8</th>
				<th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--background-modifier-border);">\u30C8\u30FC\u30AF\u30F3</th>
				<th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--background-modifier-border);">\u30B3\u30B9\u30C8</th>
			`;
      Object.entries(modelStats).forEach(([model, stats]) => {
        const row = table.createEl("tr");
        row.innerHTML = `
					<td style="padding: 8px;">${model}</td>
					<td style="text-align: right; padding: 8px;">${stats.count}</td>
					<td style="text-align: right; padding: 8px;">${stats.tokens.toLocaleString()}</td>
					<td style="text-align: right; padding: 8px;">$${stats.cost.toFixed(4)}</td>
				`;
      });
    }
    new import_obsidian.Setting(usageSection).setName("\u5229\u7528\u5C65\u6B74\u3092\u30EA\u30BB\u30C3\u30C8").setDesc("\u4ECA\u6708\u306E\u30C7\u30FC\u30BF\u3092\u524A\u9664\u3057\u307E\u3059\uFF08\u5143\u306B\u623B\u305B\u307E\u305B\u3093\uFF09").addButton(
      (button) => button.setButtonText("\u30EA\u30BB\u30C3\u30C8").setWarning().onClick(async () => {
        this.plugin.settings.usageHistory = this.plugin.settings.usageHistory.filter(
          (record) => {
            const recordDate = new Date(record.date);
            return recordDate.getMonth() !== currentMonth || recordDate.getFullYear() !== currentYear;
          }
        );
        await this.plugin.saveSettings();
        new import_obsidian.Notice("\u5229\u7528\u5C65\u6B74\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u307E\u3057\u305F");
        this.display();
      })
    );
    containerEl.createEl("hr", { attr: { style: "margin: 20px 0;" } });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ChatGPT Integration Settings" });
    this.displayUsageStats(containerEl);
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key (get it from platform.openai.com)").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select ChatGPT model (GPT-5 versions have different pricing)").addDropdown(
      (dropdown) => dropdown.addOption("gpt-5.2", "GPT-5.2 (Latest, Most Capable, $1.75/1M in)").addOption("gpt-5.1", "GPT-5.1 (Balanced)").addOption("gpt-5", "GPT-5 (Original)").addOption("gpt-5-mini", "GPT-5 Mini (Fast, $0.25/1M in)").addOption("gpt-5-nano", "GPT-5 Nano (Fastest, Cheapest)").addOption("gpt-4o", "GPT-4o").addOption("gpt-4o-mini", "GPT-4o Mini").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-4", "GPT-4").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0-2). Lower = more focused, Higher = more creative").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum length of response").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.maxTokens = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("System Prompt").setDesc("Default instruction for ChatGPT").addTextArea((text) => {
      text.setPlaceholder("You are a helpful assistant...").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("Response Format").setDesc("How to format the response. Use {response} as placeholder.").addTextArea((text) => {
      text.setPlaceholder("**ChatGPT:**\n{response}").setValue(this.plugin.settings.responseFormat).onChange(async (value) => {
        this.plugin.settings.responseFormat = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("\u{1F41B} Debug Mode").setDesc("Show debug logs as notices on screen. Logs are always saved to console and can be exported to chatgpt_debug_logs.txt").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`Debug mode ${value ? "enabled" : "disabled"}`);
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u{1F310} Web Search").setDesc("Enable ChatGPT to search the web for current information when needed. Uses OpenAI's web_search tool.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useWebSearch).onChange(async (value) => {
        this.plugin.settings.useWebSearch = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`Web search ${value ? "enabled" : "disabled"}`);
      })
    );
    containerEl.createEl("h3", { text: "How to use" });
    const usageEl = containerEl.createEl("div");
    usageEl.innerHTML = `
			<ol>
				<li>Select text in your note</li>
				<li>Press <kbd>Ctrl/Cmd + P</kbd> and search for "Ask ChatGPT"</li>
				<li>Wait for the response to be inserted</li>
			</ol>
			<p><strong>Commands:</strong></p>
			<ul>
				<li><strong>Ask ChatGPT about selected text</strong>: Ask a general question about the selected text</li>
				<li><strong>Ask ChatGPT with custom prompt</strong>: Specify your own question or instruction</li>
			</ul>
		`;
  }
};
