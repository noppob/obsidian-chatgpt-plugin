/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChatGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4o",
  temperature: 0.7,
  maxTokens: 2e3,
  systemPrompt: "You are a helpful assistant. Answer questions clearly and concisely.",
  responseFormat: "**ChatGPT:**\n{response}"
};
var ChatGPTPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.floatingButton = null;
    this.selectedTextCache = "";
  }
  // テキスト選択のキャッシュ（モバイル対応）
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("message-square", "Ask ChatGPT (Custom Prompt)", (evt) => {
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (markdownView) {
        const editor = markdownView.editor;
        this.askChatGPTCustom(editor);
      } else {
        new import_obsidian.Notice("Please open a note first");
      }
    });
    this.registerDomEvent(document, "selectionchange", () => {
      this.handleSelectionChange();
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selectedText = editor.getSelection();
        if (selectedText && selectedText.trim()) {
          menu.addItem((item) => {
            item.setTitle("\u2728 Ask ChatGPT").setIcon("message-square").onClick(async () => {
              this.askChatGPT(editor);
            });
          });
          menu.addItem((item) => {
            item.setTitle("\u{1F4AC} Ask ChatGPT (Custom)").setIcon("edit").onClick(async () => {
              this.askChatGPTCustom(editor);
            });
          });
        }
      })
    );
    this.addCommand({
      id: "ask-chatgpt",
      name: "Ask ChatGPT about selected text",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPT(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "ask-chatgpt-custom",
      name: "Ask ChatGPT with custom prompt",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const editor = markdownView.editor;
            this.askChatGPTCustom(editor);
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new ChatGPTSettingTab(this.app, this));
  }
  handleSelectionChange() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      this.hideFloatingButton();
      return;
    }
    const editor = markdownView.editor;
    const selectedText = editor.getSelection();
    console.log("handleSelectionChange - selectedText:", selectedText);
    if (selectedText && selectedText.trim()) {
      this.selectedTextCache = selectedText.trim();
      console.log("Cached text:", this.selectedTextCache);
      this.showFloatingButton();
    } else {
      this.hideFloatingButton();
    }
  }
  showFloatingButton() {
    if (this.floatingButton)
      return;
    console.log("showFloatingButton - using cached text:", this.selectedTextCache);
    this.floatingButton = document.body.createDiv("chatgpt-floating-button");
    this.floatingButton.innerHTML = "\u{1F4AC}";
    this.floatingButton.setAttribute("aria-label", "Ask ChatGPT");
    this.floatingButton.addEventListener("click", async () => {
      const cachedText = this.selectedTextCache;
      console.log("Floating button clicked. Cached text:", cachedText);
      this.hideFloatingButton();
      const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (markdownView) {
        const editor = markdownView.editor;
        await this.askChatGPTCustom(editor, cachedText);
        this.selectedTextCache = "";
      }
    });
  }
  hideFloatingButton() {
    if (this.floatingButton) {
      this.floatingButton.remove();
      this.floatingButton = null;
    }
  }
  async askChatGPT(editor) {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let selectedText = editor.getSelection();
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    try {
      new import_obsidian.Notice("Asking ChatGPT...");
      const response = await this.callOpenAI(selectedText);
      const formattedResponse = this.settings.responseFormat.replace(
        "{response}",
        response
      );
      const lastLine = editor.lastLine();
      const lastLineLength = editor.getLine(lastLine).length;
      const insertText = `

---

**Question:**
${selectedText}

${formattedResponse}
`;
      editor.replaceRange(
        insertText,
        { line: lastLine, ch: lastLineLength }
      );
      const newLastLine = editor.lastLine();
      editor.setCursor({ line: newLastLine, ch: 0 });
      new import_obsidian.Notice("Response inserted!");
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("ChatGPT Error:", error);
    } finally {
      if (wasInReadingMode) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        await markdownView.setState({ ...state, mode: "preview" }, { history: false });
      }
    }
  }
  async askChatGPTCustom(editor, cachedText) {
    console.log("askChatGPTCustom called. cachedText:", cachedText);
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!markdownView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    const state = markdownView.getState();
    const wasInReadingMode = state.mode === "preview";
    if (wasInReadingMode) {
      await markdownView.setState({ ...state, mode: "source" }, { history: false });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let selectedText = cachedText || editor.getSelection();
    console.log("selectedText after check:", selectedText);
    if (!selectedText || selectedText.trim() === "") {
      try {
        selectedText = await navigator.clipboard.readText();
        if (selectedText && selectedText.trim()) {
          new import_obsidian.Notice("Using text from clipboard");
        } else {
          new import_obsidian.Notice("Please select text or copy it to clipboard first");
          return;
        }
      } catch (e) {
        new import_obsidian.Notice("Please select text first");
        return;
      }
    }
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your OpenAI API key in settings");
      return;
    }
    new InteractiveChatModal(
      this.app,
      this,
      selectedText,
      editor,
      wasInReadingMode ? { view: markdownView, state, wasInReadingMode } : void 0
    ).open();
  }
  async callOpenAI(prompt) {
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.settings.model,
        messages: [
          {
            role: "system",
            content: this.settings.systemPrompt
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: this.settings.temperature,
        max_tokens: this.settings.maxTokens
      })
    });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message || "OpenAI API Error");
    }
    if (!data.choices || data.choices.length === 0) {
      throw new Error("No response from ChatGPT");
    }
    return data.choices[0].message.content.trim();
  }
  // 会話履歴を使ったOpenAI API呼び出し（対話型モーダル用）
  async callOpenAIWithHistory(messages) {
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.settings.model,
        messages,
        temperature: this.settings.temperature,
        max_tokens: this.settings.maxTokens
      })
    });
    const data = response.json;
    if (data.error) {
      throw new Error(data.error.message || "OpenAI API Error");
    }
    if (!data.choices || data.choices.length === 0) {
      throw new Error("No response from ChatGPT");
    }
    return data.choices[0].message.content.trim();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var InteractiveChatModal = class extends import_obsidian.Modal {
  constructor(app, plugin, selectedText, editor, readingModeInfo) {
    super(app);
    // 会話履歴（API送信用、システムプロンプト + 選択テキスト含む）
    this.messages = [];
    // 表示用会話履歴（ユーザーとアシスタントのやり取りのみ）
    this.displayMessages = [];
    this.isLoading = false;
    this.plugin = plugin;
    this.selectedText = selectedText;
    this.editor = editor;
    this.readingModeInfo = readingModeInfo;
    console.log("InteractiveChatModal created. Selected text:", selectedText);
    console.log("Selected text length:", selectedText.length);
    this.messages.push({
      role: "system",
      content: this.plugin.settings.systemPrompt
    });
    this.messages.push({
      role: "system",
      content: `Selected context from the document:

${selectedText}`
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("chatgpt-interactive-modal");
    contentEl.createEl("h2", { text: "\u{1F4AC} ChatGPT Interactive Chat" });
    const contextSection = contentEl.createDiv("chatgpt-context-section");
    const contextHeader = contextSection.createDiv("chatgpt-context-header");
    contextHeader.createEl("strong", { text: "\u{1F4C4} Selected Context" });
    const toggleIcon = contextHeader.createSpan("chatgpt-toggle-icon");
    toggleIcon.textContent = "\u25BC";
    const contextContent = contextSection.createDiv("chatgpt-context-content");
    contextContent.style.display = "block";
    const contextText = contextContent.createEl("div", { cls: "chatgpt-context-text" });
    contextText.textContent = this.selectedText.length > 200 ? this.selectedText.substring(0, 200) + "..." : this.selectedText;
    contextHeader.addEventListener("click", () => {
      if (contextContent.style.display === "none") {
        contextContent.style.display = "block";
        toggleIcon.textContent = "\u25BC";
      } else {
        contextContent.style.display = "none";
        toggleIcon.textContent = "\u25B6";
      }
    });
    this.conversationEl = contentEl.createDiv("chatgpt-conversation");
    const inputSection = contentEl.createDiv("chatgpt-input-section");
    this.inputEl = inputSection.createEl("textarea", {
      placeholder: "Ask a question about the selected text...",
      cls: "chatgpt-input"
    });
    this.inputEl.setAttribute("inputmode", "text");
    this.inputEl.setAttribute("autocomplete", "off");
    this.inputEl.setAttribute("autocorrect", "off");
    this.inputEl.setAttribute("spellcheck", "false");
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSend();
      }
    });
    const buttonContainer = inputSection.createDiv("chatgpt-button-container");
    this.sendBtn = buttonContainer.createEl("button", { text: "\u9001\u4FE1", cls: "chatgpt-send-btn" });
    this.sendBtn.addEventListener("click", () => this.handleSend());
    this.insertBtn = buttonContainer.createEl("button", { text: "\u633F\u5165\u3057\u3066\u9589\u3058\u308B", cls: "chatgpt-insert-btn" });
    this.insertBtn.addEventListener("click", () => this.handleInsertAndClose());
    const cancelBtn = buttonContainer.createEl("button", { text: "\u30AD\u30E3\u30F3\u30BB\u30EB", cls: "chatgpt-cancel-btn" });
    cancelBtn.addEventListener("click", () => this.close());
    setTimeout(() => this.inputEl.focus(), 100);
  }
  async handleSend() {
    const userInput = this.inputEl.value.trim();
    if (!userInput || this.isLoading)
      return;
    this.displayMessages.push({ role: "user", content: userInput });
    this.messages.push({ role: "user", content: userInput });
    this.inputEl.value = "";
    this.renderConversation();
    this.setLoading(true);
    try {
      const response = await this.plugin.callOpenAIWithHistory(this.messages);
      this.displayMessages.push({ role: "assistant", content: response });
      this.messages.push({ role: "assistant", content: response });
      this.renderConversation();
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("ChatGPT Error:", error);
      this.displayMessages.pop();
      this.messages.pop();
      this.inputEl.value = userInput;
    } finally {
      this.setLoading(false);
      this.inputEl.focus();
    }
  }
  renderConversation() {
    this.conversationEl.empty();
    if (this.displayMessages.length === 0) {
      const emptyMsg = this.conversationEl.createDiv("chatgpt-empty-message");
      emptyMsg.textContent = "\u8CEA\u554F\u3092\u5165\u529B\u3057\u3066\u4F1A\u8A71\u3092\u59CB\u3081\u307E\u3057\u3087\u3046";
      return;
    }
    this.displayMessages.forEach((msg) => {
      const messageEl = this.conversationEl.createDiv(`chatgpt-message chatgpt-message-${msg.role}`);
      const iconEl = messageEl.createSpan("chatgpt-message-icon");
      iconEl.textContent = msg.role === "user" ? "\u{1F4AC}" : "\u{1F916}";
      const contentEl = messageEl.createDiv("chatgpt-message-content");
      contentEl.textContent = msg.content;
    });
    this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
  }
  setLoading(loading) {
    this.isLoading = loading;
    this.sendBtn.disabled = loading;
    this.insertBtn.disabled = loading;
    this.inputEl.disabled = loading;
    if (loading) {
      this.sendBtn.textContent = "\u9001\u4FE1\u4E2D...";
      const loadingMsg = this.conversationEl.createDiv("chatgpt-message chatgpt-message-loading");
      loadingMsg.innerHTML = '<span class="chatgpt-message-icon">\u{1F916}</span><div class="chatgpt-message-content">\u8003\u3048\u4E2D...</div>';
      this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
    } else {
      this.sendBtn.textContent = "\u9001\u4FE1";
      const loadingMsg = this.conversationEl.querySelector(".chatgpt-message-loading");
      if (loadingMsg)
        loadingMsg.remove();
    }
  }
  async handleInsertAndClose() {
    if (this.displayMessages.length === 0) {
      new import_obsidian.Notice("\u4F1A\u8A71\u5C65\u6B74\u304C\u3042\u308A\u307E\u305B\u3093");
      return;
    }
    let conversationText = `

---

**Selected Context:**
${this.selectedText}

**ChatGPT Conversation:**

`;
    this.displayMessages.forEach((msg, index) => {
      const questionNum = Math.floor(index / 2) + 1;
      if (msg.role === "user") {
        conversationText += `**Q${questionNum}:** ${msg.content}

`;
      } else {
        conversationText += `**A${questionNum}:** ${msg.content}

`;
      }
    });
    const lastLine = this.editor.lastLine();
    const lastLineLength = this.editor.getLine(lastLine).length;
    this.editor.replaceRange(
      conversationText,
      { line: lastLine, ch: lastLineLength }
    );
    const newLastLine = this.editor.lastLine();
    this.editor.setCursor({ line: newLastLine, ch: 0 });
    new import_obsidian.Notice("\u4F1A\u8A71\u5C65\u6B74\u3092\u633F\u5165\u3057\u307E\u3057\u305F\uFF01");
    this.close();
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.readingModeInfo && this.readingModeInfo.wasInReadingMode) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      await this.readingModeInfo.view.setState(
        { ...this.readingModeInfo.state, mode: "preview" },
        { history: false }
      );
    }
  }
};
var ChatGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ChatGPT Integration Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key (get it from platform.openai.com)").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select ChatGPT model").addDropdown(
      (dropdown) => dropdown.addOption("gpt-4o", "GPT-4o (Latest, Recommended)").addOption("gpt-4o-mini", "GPT-4o Mini (Faster, Cheaper)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-4", "GPT-4").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0-2). Lower = more focused, Higher = more creative").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum length of response").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.maxTokens = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("System Prompt").setDesc("Default instruction for ChatGPT").addTextArea((text) => {
      text.setPlaceholder("You are a helpful assistant...").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("Response Format").setDesc("How to format the response. Use {response} as placeholder.").addTextArea((text) => {
      text.setPlaceholder("**ChatGPT:**\n{response}").setValue(this.plugin.settings.responseFormat).onChange(async (value) => {
        this.plugin.settings.responseFormat = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    containerEl.createEl("h3", { text: "How to use" });
    const usageEl = containerEl.createEl("div");
    usageEl.innerHTML = `
			<ol>
				<li>Select text in your note</li>
				<li>Press <kbd>Ctrl/Cmd + P</kbd> and search for "Ask ChatGPT"</li>
				<li>Wait for the response to be inserted</li>
			</ol>
			<p><strong>Commands:</strong></p>
			<ul>
				<li><strong>Ask ChatGPT about selected text</strong>: Ask a general question about the selected text</li>
				<li><strong>Ask ChatGPT with custom prompt</strong>: Specify your own question or instruction</li>
			</ul>
		`;
  }
};
